# use script to convert vcf to dadi SFS
#  https://groups.google.com/group/dadi-user/attach/15ae6994986666dc/convert_vcf_to_dadi_input.pl?part=0.1&authuser=0&view=1
#
# requirs vcffile, genomefastafile and a list file decribing the samples, 2 columns
# 

cd ~data/bam_fixrg_dedup/freebayes/dadi

perl convert_vcf_2_dadi.pl ~/data/symphodus_melops.fasta freebayes.SNPs.filtered.final.98.recode.vcf list2

# Start dady
python
import numpy 
import dadi

################
# load  data
print 'Reading data'
dd = dadi.Misc.make_data_dict('list2.data')
data = dadi.Spectrum.from_data_dict(dd, ['Skagerak','Northsea'], [33,24], polarized=False)
# end loading data
################

################
### Calculate descriptive statistics
ns = data.sample_sizes
print 'DADI analysis ================================================'
print 'Raw data: file list2.fs'
print 'samples sizes:', ns
print 
S = data.S()
print "Segregating sites:",S
Fst = data.Fst()
print "FST:",Fst
print "Marginalized Spectrum populations aka combining Skagerak + Northsea"
margdata = data.marginalize([1])
theta_w =  margdata.Watterson_theta()
print "Watterson's theta:", theta_w
# end calculate descriptive statistics
################

##########################
#### pre-otimization steps
# define grid size
pts_l = [40,50,60]

# define bounds
upper_bound = [100, 100, 100, 10, 3, 3]
lower_bound = [1e-2, 1e-2, 1e-2, 0, 0, 0]

#parametrs
p0 = [2,0.1,2,1,0.2,0.2]
# Perturb our parameters before optimization.
p0 = dadi.Misc.perturb_params(p0, fold=1, upper_bound=upper_bound,lower_bound=lower_bound)
# end-optimization steps
#############################

# we will use all models provided in dady "Demographics2D.py"
# 1. snm =  Standard neutral model, populations never diverge.
# 2. bottlegrowth = Instantanous size change followed by exponential growth with no population split.
# 3. bottlegrowth_split = Instantanous size change followed by exponential growth then split.
# 4. bottlegrowth_split_mig = Instantanous size change followed by exponential growth then split with migration.
# 5. split_mig = Split into two populations of specifed size, with migration.
# 6. IM =  Isolation-with-migration model with exponential pop growth.
# 7. IM_pre = Isolation-with-migration model with exponential pop growth and a size change prior to split.


# nub: The bottleneck size for both pops
# nue: The recovery size for both pops
# m1: The scaled migration rate
# m2: The scaled migration rate
# T1: The scaled time of the bottleneck.
# T2: The scaled time of the recovery
# T3: The scaled time of the admixture
# n1,n2: Size of fs to generate.
# pts: Number of points to use in grid for evaluation

############################################################ Standard neutral model ###################################################

# define 2D netural model
func = dadi.Demographics2D.snm
func_ex = dadi.Numerics.make_extrap_log_func(func)

##########################
#### optimization
print('Beginning optimization ************************************************')
popt = dadi.Inference.optimize_log(p0, data, func_ex, pts_l, 
                                   lower_bound=lower_bound,
                                   upper_bound=upper_bound,
                                   verbose=len(p0), maxiter=1000)
# The verbose argument controls how often progress of the optimizer should be
# printed. It's useful to keep track of optimization process.
print('Finshed optimization **************************************************')
# end optimization 
#############################

##########################
#### print results and make plot
print('Best-fit parameters: {0}'.format(popt))
# Calculate the best-fit model AFS.
model = func_ex(popt, ns, pts_l)
# Likelihood of the data given the model AFS.
ll_model = dadi.Inference.ll_multinom(model, data)
print('Maximum log composite likelihood: {0}'.format(ll_model))
# Plot a comparison of the resulting fs with the data.
import pylab
pylab.figure(1)
dadi.Plotting.plot_2d_comp_multinom(model, data, vmin=1, resid_range=3,pop_ids =('Skagerak','Northsea'))
print('Maximum log composite likelihood: {0}'.format(ll_model))
pylab.savefig('Skagerak_Northsea.2Dsnm.png', dpi=300)
# end print results and make plot
#############################


############################################################ BOTTLEGROWTH ########################################################


# define 2D netural model
# nuB = Ratio of population size after instantanous change to ancient population size
# nuF = Ratio of contempoary to ancient population size
# T = Time in the past at which instantaneous change happened and growth began (in units of 2*Na generations) 

func = dadi.Demographics2D.bottlegrowth
func_ex = dadi.Numerics.make_extrap_log_func(func)

##########################
#### optimization
print('Beginning optimization ************************************************')
popt = dadi.Inference.optimize_log(p0, data, func_ex, nuB, nuF, T, pts_l, 
                                   lower_bound=lower_bound,
                                   upper_bound=upper_bound,
                                   verbose=len(p0), maxiter=1000)
# The verbose argument controls how often progress of the optimizer should be
# printed. It's useful to keep track of optimization process.
print('Finshed optimization **************************************************')
# end optimization 
#############################

##########################
#### print results and make plot
print('Best-fit parameters: {0}'.format(popt))
# Calculate the best-fit model AFS.
model = func_ex(popt, ns, pts_l)
# Likelihood of the data given the model AFS.
ll_model = dadi.Inference.ll_multinom(model, data)
print('Maximum log composite likelihood: {0}'.format(ll_model))
# Plot a comparison of the resulting fs with the data.
import pylab
pylab.figure(1)
dadi.Plotting.plot_2d_comp_multinom(model, data, vmin=1, resid_range=3,pop_ids =('Skagerak','Northsea'))
print('Maximum log composite likelihood: {0}'.format(ll_model))
pylab.savefig('Skagerak_Northsea.2Dsnm.png', dpi=300)
# end print results and make plot
#############################








# Note on units
# mij = migration rate
# Ne = effective population
# mu = mutaiton rate
# K = numer of segregating sites
# L = numer of SNPs
# g = generation time

# For example, I have got θ, nu, mij and T.
# In dadi manual, Nref is calculated with θ/4u. While, in some papers with SNP data, θ/4uL is used to get Nref,
# where L is number of analyzed sites. Which equation is OK? = theta = 4*mu*L*Nref 
# Additionally, if I got Nref=1000, nu=0.5, mij=0.2 , T=2 and generation time g=2 :
# Real time = 2*Nref*T*g = 2*1000*2*2 = 8000 years
# Real population size = nu*Nref = 0.5*1000 = 500 individuals
# Real migration rates = mij/2Nref = 0.2/(2*1000)  = 1e-4     
# which means 0.05 individuals each generation are migrating from population j to population i.
